
#include "ch.h"
#include "hal.h"
#include "r2p/Middleware.hpp"
#include <r2p/msg/pixy.hpp>
#include <r2p/msg/pixyBuffer.hpp>
#include <r2p/msg/proximity.hpp>

#define PIXY_ARRAYSIZE              100
#define PIXY_START_WORD             0xaa55
#define PIXY_START_WORD_CC          0xaa56
#define PIXY_START_WORDX            0x55aa

typedef struct
{
	uint16_t signature;
	uint16_t x;
	uint16_t y;
	uint16_t width;
	uint16_t height;
	uint16_t angle; // angle is only available for color coded blocks
} Block;

typedef enum
{
	NORMAL_BLOCK,
	CC_BLOCK // color code block
} BlockType;

static BlockType g_blockType; // use this to remember the next object block type between function calls
static int g_skipStart = 0;
static Block *g_blocks;

uint16_t getWord(void)
{
	// this routine assumes little endian
	uint16_t w;
	uint8_t c;
	c = sdGetTimeout(&SD3, MS2ST(100));
	w = sdGetTimeout(&SD3, MS2ST(100));
	w <<= 8;
	w |= c;
	return w;
}

int getStart(void)
{
	uint16_t w, lastw;

	lastw = 0xffff; // some inconsequential initial value

	while(1)
	{
		w = getWord();
		if (w==0 && lastw==0)
			return 0; // in I2C and SPI modes this means no data, so return immediately
		else if (w==PIXY_START_WORD && lastw==PIXY_START_WORD)
		{
			g_blockType = NORMAL_BLOCK; // remember block type
			return 1; // code found!
		}
		else if (w==PIXY_START_WORD_CC && lastw==PIXY_START_WORD)
		{
			g_blockType = CC_BLOCK; // found color code block
			return 1;
		}
		else if (w==PIXY_START_WORDX) // this is important, we might be juxtaposed
			sdGetTimeout(&SD3, MS2ST(100)); // we're out of sync! (backwards)
		lastw = w; // save
	}
}




msg_t pixy_node(void *arg) {
	r2p::Publisher<r2p::PixyMsg> pixy_pub;
	r2p::Node node("pixy");
	r2p::PixyMsg * msgp;
	sdStart(&SD3, NULL);
	node.advertise(pixy_pub,"pixy");
	int curr=0;
	int prev=0;
	for (;;) {
		curr = getStart();
		if (curr) // two start codes means start of new frame
		{

			int checksum = getWord();
			    if (checksum==PIXY_START_WORD) // we've reached the beginning of the next frame
			    {
			      g_skipStart = 1;
			      g_blockType = NORMAL_BLOCK;
			      break;
			    }
			    else if (checksum==PIXY_START_WORD_CC)
			    {
			      g_skipStart = 1;
			      g_blockType = CC_BLOCK;
			      break;
			    }
			    else if (checksum==0)
			      break;

			uint16_t w;
			w = getWord();
			int sig = w;
			w = getWord();
			int x=w;
			w = getWord();
			int y=w;
			w = getWord();
			int width=w;
			w = getWord();
			int height=w;
			if (pixy_pub.alloc(msgp)) {
				msgp->checksum =checksum;
				msgp->signature=sig;
				msgp->x = x;
				msgp->y = y;
				msgp->width = width;
				msgp->height = height;
				pixy_pub.publish(*msgp);
			}
		}
		prev=curr;
		r2p::Thread::sleep(r2p::Time::ms(50));
	}



	return CH_SUCCESS;
}


/*
msg_t pixy_node(void *arg) {

	r2p::Publisher<r2p::PixyBufferMsg> pixy_pub;
	r2p::Node pixy_n("pixy",false);
	sdStart(&SD3, NULL);
	pixy_n.advertise(pixy_pub, "pixy", r2p::Time::INFINITE);


	for(;;){
		r2p::PixyBufferMsg * msgp;
		if (pixy_pub.alloc(msgp)) {
		for(int i =0 ; i<9;i++){
				char temp[2];
				temp[1] = 	sdGetTimeout(&SD3, MS2ST(100));
				temp[0] =   sdGetTimeout(&SD3, MS2ST(100));
				msgp->buffer[i] = toInt(temp);
			}

	pixy_pub.publish(*msgp);
	}
	r2p::Thread::sleep(r2p::Time::ms(200));
	}
 */

/*
char toCheck [4];
toCheck[0] = sdGetTimeout(&SD3, MS2ST(100));
toCheck[1] = sdGetTimeout(&SD3, MS2ST(100));
toCheck[2] = sdGetTimeout(&SD3, MS2ST(100));

for (;;) {
	//if (node.spin(r2p::Time::ms(300))) {
	toCheck[3] = sdGetTimeout(&SD3, MS2ST(100));
	if(sync(toCheck)){

		if (pixy_pub.alloc(msgp)) {
			char check_temp[2];
			check_temp[1]=sdGetTimeout(&SD3, MS2ST(100));
			check_temp[0]=sdGetTimeout(&SD3, MS2ST(100));

			char Sig_temp[2];
			Sig_temp[1]=sdGetTimeout(&SD3, MS2ST(100));
			Sig_temp[0]=sdGetTimeout(&SD3, MS2ST(100));

			char x_temp[2];
			x_temp[1]=sdGetTimeout(&SD3, MS2ST(100));
			x_temp[0]=sdGetTimeout(&SD3, MS2ST(100));

			char y_temp[2];
			y_temp[1]=sdGetTimeout(&SD3, MS2ST(100));
			y_temp[0]=sdGetTimeout(&SD3, MS2ST(100));

			char width_temp[2];
			width_temp[1]=sdGetTimeout(&SD3, MS2ST(100));
			width_temp[0]=sdGetTimeout(&SD3, MS2ST(100));

			char height_temp[2];
			height_temp[1]=sdGetTimeout(&SD3, MS2ST(100));
			height_temp[0]=sdGetTimeout(&SD3, MS2ST(100));

			int check = toInt(check_temp);
			int sig = toInt(Sig_temp);
			int x = toInt(x_temp);
			int y = toInt(y_temp);
			int width = toInt(width_temp);
			int height = toInt(height_temp);
			msgp->checksum=check;
			msgp->signature=sig;
			msgp->x_center = x;
			msgp->y_center = y;
			msgp->width = width;
			msgp->height = height;
			msgp->pack_number = pack_number;
			pixy_pub.publish(*msgp);
		}
		toCheck[0] = sdGetTimeout(&SD3, MS2ST(100));
		toCheck[1] = sdGetTimeout(&SD3, MS2ST(100));
		toCheck[2] = sdGetTimeout(&SD3, MS2ST(100));
	}else
	{
		for(int i=0;i<3;i++)
		{
			toCheck[i]=toCheck[i+1];
		}

	}
	r2p::Thread::sleep(r2p::Time::ms(100));
}
 */
/*int16_t toInt(char temp[]) {
	int16_t first;
	int16_t second;

	first = (int16_t)temp[0];
	first = first *16 *16;
	second  = (int16_t)temp[1];

	return first + second;
}
 */





